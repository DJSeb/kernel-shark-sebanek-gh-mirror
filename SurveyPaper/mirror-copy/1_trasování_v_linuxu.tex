\chapter{Trasování v Linuxu}

V této kapitole si představíme trasování systémů, specificky trasování v operačním systému Linux. Zároveň představíme i některé nástroje, díky kterým lze trasovací data sbírat. Po přečtení kapitoly by měl mít čtenář alespoň hrubou představu o konceptu trasování a o jeho podpoře trasování na Linuxu, hlavně o částech, které budou relevantní pro zbytek práce.

\section{Definice trasování a použití}

Trasování lze definovat jako \uv{sběr událostí a jejich dat, které se staly během běhu trasovaného systému či trasovaného procesu}. Logování lze definovat podobně, nicméně trasování je většinou akce sběru nízkoúrovňových dat, která slouží hlavně vývojářům. Trasovací data pak slouží k pohledu na chování systému jako celku, jak spolu některé události souvisí a detailní informace o každé události. Tato data převážně slouží k diagnostice systémů - ať už se jedná o hledání anomálií, míst pro optimalizace, či jako způsob ladění.

\section{Podpora v Linuxu}

Linux široce podporuje trasování kernelu různými způsoby, některé na sebe mohou navazovat. Jedním ze způsobů je použití tracepointů v kernelu. Dalším je \emph{tracefs} systém k trasování událostí. Zajímavé jsou kprobes. Pro tuto práci nejzajímavějšími technologiemi pak budou \emph{ftrace} a právě \emph{systém k trasování událostí}. Krom vyjmenovaných existují další způsoby a nástroje pro trasování, nicméně vyjmenování všech není ani nutné, ani zajímavé.

Následující sekce nepředstavují vyčerpávající seznam existujících technologií, nýbrž jen výběr takových, které se autorovi zdály relevantní k této práci či obecně zajímavé. Relevantní technologie jsou více rozepsané. Technologie zajímavé jsou pak zmíněny na konci a bez tolika detailů.

\subsection{Linuxové Kernel Tracepoints}
\label{tracepoints}

Pro trasování částí kernelu obsahuje Linux podporu skrze tzv. tracepoints, počeštěně \uv{tracepointy}. Těmi se dají označit místa v kódu jádra a k těmto místům připojit sondovací funkce. Dokumentace kernelu rozlišuje tracepointy na zapnuté a vypnuté. Vypnuté tracepointy nemají na chod kernelu vliv, kromě nepodstatné časové (kontrola podmínky) a paměťové (existence v kódu) stopy. Tracepoint je vypnutý, pokud nedostal sondovací funkci. Opakem je pak zapnutý tracepoint - když kód přechází přes něj, zavolá se sonda tracepointu a po své práci se vrací na místo volání. Sondovací funkce mohou dělat různou práci, ale častým úkolem je vytvořit trasovací událost v místě tracepointu a zapsat ji na konec trasovacího bufferu. Trasovací buffer je v paměti, má omezenou velikost a je cyklický (po zapsání \texttt{N} událostí, kde \texttt{N} je kapacita bufferu, se před zapsáním další události vyhodí událost nejstarší).

Tracepointy lze deklarovat a definovat pomocí souboru \texttt{linux/tracepoint.h}. V tomto souboru jsou definována makra a funkce pro tyto účely. Makrům se dodají názvy tracepointu, prototyp sondy a názvy jejích parametrů. Hlavička také obsahuje soubor funkcí, s nimiž lze přiřazovat sondy tracepointům pomocí registrací a deregistrací. Lze také kontrolovat, zdali je tracepoint zapnutý, přičemž toto je implementováno tak, že není potřeba řešit podmíněné větvení výpočtu. Důležitou funkcí pak je i volání sondy daného tracepointu přes funkci \texttt{trace\_<název tracepointu>(<argumenty>)}. Dokumentace kernelu doporučuje nazývat tracepointy ve stylu \uv{subsystém\_název-události}. Takto se standardně nazývají ostatní tracepointy v jádře. Tracepoint bude po definici globálně přístupný v celém kernelu a tento formát názvů zabraňuje kolizím. Sondy se předávají při registraci a jsou to nějaké funkce. Při kompilaci se pak kontroluje správný typ funkce.

Tracepointy pak lze vložit jak do regulárních funkcí, tak do inline funkcí, statických inline funkcí i do rozvinutých cyklů. Nedoporučuje se volat tracepointy či kontrolovat zdali jsou zapnuté uvnitř hlavičkových souborů z důvodů vedlejších efektů include direktiv se zapnutým makrem \texttt{CREATE\_TRACE\_POINTS}, které nakonec vyúsťují v nemalý inline a mohou kernel zpomalovat. Proto existuje navíc soubor \texttt{tracepoint-defs.h}, který obsahuje funkce, které se mají použít namísto přímého volání a kontroly.

\subsection{Trasování událostí}

S tracepointy \ref{tracepoints} generujícími události můžeme pracovat i více. Základní práci s tracepointy, které vytváří trasovací události, umožňuje systém trasování událostí (dále také nazýván \uv{trasovací systém pro události}). Události zde označují statické tracepointy, které jsou v kernelu k dispozici po kompilaci.

\subsubsection*{Adresář /sys/kernel/tracing/}
Systém s podporou trasování obsahuje v adresáři \texttt{/sys/kernel/tracing/} (dále \uv{trasovací adresář}) soubory a podadresáře, díky nimž lze komunikovat s trasovacím systémem pro události. Dohromady se tomuto souborovému systému říká \emph{tracefs}. Předně lze zde zapnout či vypnout různé typy událostí různými způsoby, např. pro zapnutí události \uv{sched/sched\_waking} lze buď napsat:
\begin{code}
    echo 1 > /sys/kernel/tracing/events/sched/sched_waking/enable
\end{code}
nebo
\begin{code}
    echo 'sched_waking' >> /sys/kernel/tracing/set\_event
\end{code}
Pro vypnutí stačí buď předat v prvním způsobu nulu, v druhém pak stačí před název události vložit vykřičník (stále v rozsahu jednoduchých uvozovek). Je možné zapnout či vypnout i všechny události daného podsystému, nebo pracovat s událostmi pouze nějakého modulu kernelu. 

\subsubsection*{Formát událostí}
Každá událost obsahuje i soubor se svým formátem. V něm je definována struktura dat události, název a identifikátor události a formát tisku této události. Předepsaný formát je pak využíván při čtení dat z binárních trasovacích záznamů. Data události jsou strukturována do datových polí ve formátu \texttt{field:field-type field-name; offset:N; size:N;}. Offset značí offset daného pole v trasovacím záznamu a size je velikost v bajtech. Každá událost obsahuje pole označená prefixem \texttt{common\_}, události pak mohou dále specifikovat vlastní pole, např. událost \uv{sched\_wakeup} obsahuje pole s ID procesu probouzeným procesem, jemuž událost patří.

\subsubsection*{Filtrování událostí}

Ne všechny události daného typu je nutné sbírat při trasování, někdy nás mohou zajímat jenom pokud splňují další podmínky. Trasování událostí dovoluje specifikovat filtry, tj. predikáty, které se vyhodnotí při každém záznamu dané události. Tyto filtry pak mohou cílit na jednotlivá datová pole. Pro číselná pole se dají použít klasické relační operátory na ekvivalenci (\texttt{==}), rozdílnost (\texttt{!=}), vztah menší/větší (nebo roven) (\texttt{<}, \texttt{>}, \texttt{<=}, \texttt{>=}), bitové \uv{a zároveň} (\texttt{\&}). Pro pole s textem se dají použít operátory na ekvivalenci, rozdílnost a podobnost (\texttt{\char`~}). Operátor pro podobnost pak očekává text ve složitých uvozovkách, který může obsahovat sekvenci abecedních znaků, wildcard znaky \texttt{?} a \texttt{*}, nebo třídu znaků (mezi hranatými závorkami \texttt{[]}). Například můžeme zkusit filtrovat pro jméno končící na \uv{shell} a písmena \uv{s}, nebo \uv{t}, nebo \uv{u}: \texttt{some\_text\_field \char`~~"*shell[stu]"}.
Pokud je v textovém poli ukazatel na string v uživatelském prostoru, musíme za název pole dodat \texttt{.ustring}. Pokud obsahuje pole ukazatel na funkci, pak musí být dle formátu typu \texttt{long} a za název pole se musí připsat \texttt{.function}. Pole typu \texttt{cpumask} nebo skalární pole obsahující číslo CPU lze filtrovat pomocí uživatelem zadané CPU masky ve formátu seznamu CPU. Například výraz \texttt{target\_cpu \& CPUS{17-42}} vyfiltruje události, jejichž hodnota v poli \texttt{.target\_cpu} se nachází v rozsahu CPU 17 až 42. Predikáty pro různá pole se dají spojovat přes boolovské operátory a oddělovat závorkami.

Filtry lze přidat k dané události v trasovacím adresáři do souboru \texttt{filter} v adresáři události. Stačí přes \texttt{echo} zapsat do obsahu tohoto souboru daný predikát. Pokud chceme filtry vyčistit, stačí do souboru zapsat \texttt{0}.

Filtry lze nastavovat i pro celé subsystémy (resp. lze nastavit filtr všem událostem přes nastavení pro subsystém, čímž omezíme nutnost opakování stejných příkazů). V tom případě je nutno si dát pozor, aby všechny události v podsystému měly filtrovaná pole. Pokud tomu tak není, je daný filtr ignorován a událost používá filtr předchozí. Jistojistě budou vždy fungovat filtry na pole společná všem událostem.

\subsubsection*{Spouštěče událostí}

Každá událost může navíc spouštět \uv{příkazy}, když je zrovna vyvolána. Událost může mít vícero spouštěčů. Tyto příkazy mají vlastní filtry, podobně jako filtry pro události. Událost, která neprostoupí filtrem nějakého spouštěče tento spouštěč nevyvolá. Spouštěče bez filtrů se vždy spustí. Podstatnou vlastností spouštěčů je, že je lze spustit, aniž by byla samotná událost trasována. Tracepoint události se zavolá, ale pokud není zapnut, nebude událost trasována, nicméně spouštěče (a jejich filtry) spuštěny budou. Tohoto \uv{polo-vypnutí} se dá docílit skrze příkazy spouštěčů.

Podobně jako u filtrů se spouštěče přidávají do nějakého souboru události v trasovacím adresáři. Tímto souborem je \texttt{trigger} v adresáři události, pro kterou chceme spouštěč vytvořit. Formát výrazu přidání spouštěče:
\begin{code}
    echo 'command[:count] [if filter]' > trigger
\end{code}
Pro odstranění stačí před \texttt{command} přidat vykřičník. Část \texttt{if filter} vyžaduje napsání slova if a pak filtrovacího predikátu, jako pro filtr události. Část s \texttt{:count} pak říká, kolikrát bude spouštěč spuštěn. Zmíníme i chování operátoru \texttt{>}, který se chová jako operátor \texttt{>>} pro operace přidání a odebrání, tj. je nutno odebírat po jednom.

Spouštěcí příkazy jsou předem dány a jsou to právě tyto:
\begin{itemize}
    \item \emph{enable\_event/disable\_event} - tyto příkazy buď zapnou nebo \uv{polo-vypnou} specifikovanou událost při každém vyvolání spouštěcí události. Formát pro tyto příkazy je \texttt{enable\_event/disable\_event:<system>:<event>}, kde \texttt{<system>} je název systému, kterému patří událost jménem \texttt{<event>}. U těchto příkazů není povoleno mít více spouštěčů (buď zapínacích, nebo vypínacích) pro jeden typ události.
    \item \emph{stacktrace} - tento příkaz zapíše záznam zásobníku do trasovacího bufferu. Může být jen jeden na spouštěcí událost.
    \item \emph{snapshot} - tento příkaz vytvoří snapshot při spouštěcí události. Může být jen jeden na spouštěcí událost. Snapshot ve zkratce prohodí současný trasovací buffer s novým bufferem a původní buffer si uloží do souboru \texttt{snapshot}. Lze tak nasbírat zajímavé informace bez neustálých zápisů na disk. 
    \item \emph{traceon/traceoff} - tyto příkazy zapínají, nebo vypínají trasovací systém. Není povoleno mít více stejných příkazů na spouštěcí událost.
    \item \emph{hist} - tento příkaz agreguje vyvolávání spouštěcí události. Data jsou pak využívána v histogramech událostí \ref{histogramy-událostí}, další z trasovacích technologií.
\end{itemize}

\subsection{Ftrace}
\label{Ftrace}

Ftrace je interní nástroj kernelu pro vývojáře a návrháře systémů, díky kterému lze nahlédnout do chodu kernelu. Název pochází ze slov \uv{function tracer}, nicméně tento nástroj má dnes funkcionality širší. Jeho hlavním účelem je analýza latencí a výkonu mimo uživatelský prostor. Jedním z nejčastějších využití je při trasování událostí, kde Ftrace využívá schopnosti tracefs. Pokud není tracefs aktivní v Linuxu, použitím Ftrace aktivován bude (tj. tracefs bude připojen přes \texttt{mount} příkaz). Ftrace pak má v trasovacím adresáři (připomeneme, že to je \texttt{/sys/kernel/tracing}) přístup ke svým řídícím a výstupním souborům. Souborů a adresářů je více, představíme si jen pár z nich, abychom se lépe s Ftrace seznámili.
\begin{itemize}
    \item \emph{available\_tracers} - tento soubor má seznam tracerů, které byly zkompilovány do kernelu. Jeden ze zdejších tracerů lze skrze \texttt{echo} zapsat do souboru \emph{current\_tracer}, který značí, který tracer má Ftrace při trasování použít.
    \item \emph{tracing\_cpumask} - tento soubor je maska, přes kterou lze nastavit, která CPU mají být součástí trasování přes Ftrace.
    \item \emph{trace\_options} - soubor řídí chování tracerů a tištění výstupu. V souboru je seznam nastavení pro tyto účely. Na zakázání možnosti stačí přes \texttt{echo} zapsat do souboru \texttt{no<název>}, kde <název> bude jméno možnosti. Bez zakazujícíh prefixu bude možnost zapnuta. Vyjmenujeme si pár z možností:
    \begin{itemize}
        \item print\_parent - v trasovacích datech funkcí se zobrazí volající funkce vedle trasované funkce.
        \item context-info - zobrazí se pouze data události, nebudou zobrazeny sloupce s PID, CPU či jiné zajímavé sloupce.
        \item pause-on-trace - pokud otevřeme soubor trace, pak se trasování zastaví, dokud jej nezavřeme.
        \item record-cmd - při trasování sched\_switch události se zaznamenává jak PID, tak jméná procesů. Pokud tuto možnost vypneme, nebudeme si ukládat názvy procesů a snížíme tak dopad trasování na výkon.
        \item disable\_on\_free - při zavření souboru free\_buffer se zastaví trasování.
        \item stacktrace - po každé události se zaznamená zásobník kernelu
    \end{itemize}
    \item \emph{trace} - v tomto souboru jsou výsledky posledního Ftrace trasování ve formátu čitelném lidmi. Tento soubor nekonzumuje data po přečtení, ta přetrvávají. Pokud je trasování vypnuté, bude se zobrazovat stejný obsah. Soubor by neměl být čten během aktivního trasování, výsledky nemusí být konzistentní.
    \item \emph{free\_buffer} - tento soubor je využíván při uvolňování či zmenšování trasovacího bufferu - tato akce je provedena, když je tento soubor zavřen. Zároveň je možné tímto souborem trasování zastavit, pokud k tomu Ftrace nakonfigurujeme.
    \item \emph{set\_ftrace\_pid} - Ftrace bude trasovat vlákna procesů jen a pouze s PID v tomto souboru. Pokud Ftrace nakonfigurujeme s možností \texttt{function-fork}, pak pokud proces s PID v tomto souboru udělá fork, pak PID podřízených procesů se sem přidají automaticky.
    \item \emph{kprobe\_events \& kprobe\_profile} - používají se u dynamických tracepointů, viz sekce \ref{kprobování}.
    \item \emph{stack\_max\_size} - pokud trasujeme zásobník (kernelu), tento soubor udržuje největší ze zaznamenaných velikostí zásobníků.
    \item \emph{stack\_trace} - tento soubor zobrazí největší zaznamenaný zásobník.
    \item \emph{trace\_clock} - záznamy událostí získávají časovou stopu, tedy kdy byly zaznamenány. V tomto souboru se nastavuje, který typ hodin je použit pro časové stopy, přičemž Ftrace má za výchozí hodiny lokální pro každé CPU. Typů hodin je několik, vyjmenujeme jich pouze pár:
    \begin{itemize}
        \item local - Ftrace použije hodiny lokální pro každé CPU.
        \item global - hodiny, které jsou synchronizovány pro všechna CPU, ale jsou trochu pomalejší
        \item perf - pro synchronizaci s nástrojem Perf, který tento typ hodin používá. Nástroj má v budoucnu používat Ftrace buffery a tyto hodiny pomůžou s prokládáním dat.
        \item counter - atomický čítač, nejsou to opravdové hodiny. Hodí se, pokud je nutné znát přesné pořadí událostí v celém systému (čítač je synchronizován pro všechna CPU).
        \item x86-tsc - některé architektury specifikují vlastní hodiny, x86 používá hodiny tohoto typu.
    \end{itemize}
    \item \emph{per\_cpu} - tento adresář obsahuje adresáře pro každé CPU na systému, v nichž jsou některé soubory jako v trasovacím adresáři, ale lokální pouze pro daný procesor. Například lze v \texttt{per\_cpu/cpu0/trace} vidět obsah posledního trasování na tomto CPU.
\end{itemize}

Zmínili jsme pojem \uv{tracer}. To je část kernelu, která má za úkol trasovat předem dané typy chování za běhu, zaměřuje se na nějaký aspekt systému. Ftrace má k dispozici několik tracerů, základně \emph{function tracer}, který se sonduje při vstupu do kernelových funkcí. Je možné použít i \emph{function graph tracer}, který sonduje jak při vstupu, tak při výstupu z funkce. Tím dokáže zobrazit alší informace, například dobu běhu funkce, nebo pro zkoumání volání funkcí. Dále zmíníme \emph{wakeup tracer}, ten trasuje a zaznamenává maximální latenci mezi probuzením a naplánováním úlohy s nejvyšší prioritou, podobně pak existuje i \emph{wakeup\_rt tracer}, který se zajímá pouze o real-time úlohy. Zajímavým příkladem je i \emph{nop tracer}. Pokud jej nastavíme do souboru current\_tracer, pak ostatní tracery přestanou trasovat.

\subsubsection*{Chyby}

Ftrace používá hlavně návratové kódy, které pak zpracuje jejich příjemce. Složitější chyby se pak ukládají do souboru \emph{error\_log} v trasovacím adresáři. Příkazy, které jej umějí číst, mohou z chyb vyčíst detailní informace, jsou-li k dispozici. Log je cyklický a pamatuje si nejvýše osm chyb, tj. chyby z posledních osmi příkazů.

\subsubsection*{Příklady použití}

Ukážeme pár příkladů použití Ftrace. První příklad je velmi jednoduchý, použijeme nop tracer. Čtení souboru trace po trasování s nop tracerem vypadá takto:
\begin{code}
# tracer: nop
#
# entries-in-buffer/entries-written: 0/0   #P:8
#
#                                _-----=> irqs-off
#                               / _----=> need-resched
#                              | / _---=> hardirq/softirq
#                              || / _--=> preempt-depth
#                              ||| / _-=> migrate-disable
#                              |||| /     delay
#           TASK-PID     CPU#  |||||  TIMESTAMP  FUNCTION
#              | |         |   |||||     |         |
\end{code}
Je zřejmé, že nop tracer opravdu nic netrasuje. Jediné, co nám zbylo, jsou vysvětlovací popisky a pár metadat o použitém traceru a záznamech. Nejvýše je název použitého traceru, pak počet záznamů v bufferu na počet zapsaných záznamů a vpravo počet procesorů na systému.

Druhý příklad je o trochu zajímavější. S použítím function traceru jsme získali výstup:
\begin{code}
# tracer: function
#
# entries-in-buffer/entries-written: 410067/13139037   #P:8
#
#                      _-----=> irqs-off
#                     / _----=> need-resched
#                    | / _---=> hardirq/softirq
#                    || / _--=> preempt-depth
#                    ||| / _-=> migrate-disable
#                    |||| /     delay
# TASK-PID     CPU#  |||||  TIMESTAMP  FUNCTION
#    | |         |   |||||     |         |
  node-831     [007] ..... 30994.493939: get_futex_key <-futex_wake
  node-831     [007] ..... 30994.493940: hash_futex <-futex_wake
  node-831     [007] ..... 30994.493940: _raw_spin_lock <-futex_wake
  node-831     [007] ..... 30994.493940: mark_wake_futex <-futex_wake
  node-831     [007] ..... 30994.493940: __unqueue_futex <- \
                                         mark_wake_futex
  node-831     [007] ..... 30994.493941: wake_q_add_safe <-futex_wake
  node-831     [007] ..... 30994.493941: wake_up_q <-futex_wake
  node-831     [007] ..... 30994.493941: try_to_wake_up <-wake_up_q
  node-831     [007] ..... 30994.493941: _raw_spin_lock_irqsave <-\
                                         try_to_wake_up
  node-831     [007] d.... 30994.493941: ttwu_queue_wakelist <-\
                                         try_to_wake_up
...
\end{code}
Function tracer nám zaznamenal velmi mnoho informací, jak ukazuje hlavička. Výstup jsme zkrátili (a zmáčkli, aby se vešel do kódového bloku). Všechny viditelné funkce jsou z osmého CPU, jsou z jediného procesu a týkají se probouzení. Tento výpis je z autorova počítače na Linuxovém subsystému ve Windows 11 a trasování probíhalo pouze pár vteřin.

\subsubsection{Trace-cmd}

[TODO: Zdroj oficiální kernel a man docs + https://lwn.net/Articles/410200/]

Trace-cmd je front-endová aplikace pro Ftrace, která zjednodušuje používání tohoto nástroje. Tuto aplikaci vyvinul Steven Rostedt,  o kterém ještě uslyšíme v kapitole \ref{kap-kernel-shark} o KernelSharku. Ftrace vyžaduje používání tracefs a zapisování či čtení ze souborů. S dokumentací je pak používání celkem jednoduché, což je velká výhoda u embedded systémů. Nicméně desktopové systémy mají prostředky ke složitějším nástrojům a způsobům interakce, práce se soubory pak může působit pomale. A právě nástrojem pro jednotnější použití je Trace-cmd. Další důležitou výhodou Trace-cmd je i to, že svá data ukládá v binárním formátu, resp. přímo kopíruje jejich binární reprezentaci z trasovacího bufferu, nikoliv jejich textovou verzi z Ftrace souboru \texttt{trace}. Při sběru mnoha událostí je tato vlastnost zásadní, jelikož není potřeba textový formát vytvářet a sběr je stále rychlý. Trace-cmd je důležitým nástrojem pro zbytek této práce, jelikož představuje zdroj dat pro KernelShark.

Trace-cmd dovoluje například vytvořit trasovací záznam pro nějaký proces přes svůj příkaz \texttt{trace-cmd~record~<cmd>}, kde <cmd> je jiný příkaz, jehož průběh (resp. průběh procesu, který spustí) má být trasován. Trasovací data jsou pak uložena do souboru, výchozím jménem \texttt{trace.dat}. Trace-cmd pak přes příkaz \texttt{trace-cmd report <input>}, kde <input> je název souboru vytvořeného přes Trace-cmd, dokáže vytvořit výstup, jako při čtení souboru trace v trasovacím adresáři. Trace-cmd dovoluje i trasovat přes síť s příkazem \texttt{trace-cmd listen}, což může být užitečné pro trasování embedded zařízení, ke kterým máme síťový přístup a nechceme trasování spouštět a číst přímo z nich. Pokud chceme pouze jednoduše začít trasovat přes Ftrace, pomohu příkazy \texttt{trace-cmd start} a \texttt{trace-cmd stop}. Trasovací data Ftrace lze pak extrahovat do souboru přes \texttt{trace-cmd extract}. Trace-cmd dovoluje i všechna trasování vypnout přes příkaz \texttt{trace-cmd restart}. Všechny příkazy navíc mají několik možností konfigurující jejich chování. Například, chceme-li trasovat zásobník kernelu po každé události, pak stačí zadat příkaz \texttt{trace-cmd record -T <cmd>}. Příkazů je více, tyto jsou ale jedny z nejzákladnějších.

\subsection{Perf}
\label{Perf}

[TODO: Zdroj https://perfwiki.github.io/main/ + https://www.brendangregg.com/perf.html]

Nemůžeme zmínit měření výkonu a trasování bez známého a dlouhodobě používaného programu k profilování, \emph{Perf} (původním názvem Performance Counters for Linux/PCL). Profilování vytváří statistiky o běhu systému a často se používá na zjištění toho \emph{kde} je největší výkonnová ztráta. Profilování nedokáže odpovědět na otázku \emph{proč} je nějaká část software problémová. K tomu se pak většinou zkoumají právě trasovací data v pořadí výpočtu. Profilování je nicméně velmi důležitou částí analýzy a s trasováním tvoří ty nejzákladnější pilíře výkonostní analýzy.

Nástroj Perf je dostupný již od verze kernelu 2.6 a je součástí kernelové instalace. Perf je schopen pro svou analýzu použít \uv{čítače výkonu}, což jsou hardwarové registry na CPU, které počítají různé údaje, například počet provedených instrukcí, počet přerušení, počet cache-misses, či počet špatně předpovězených větví výpočtu. Kromě toho dokáže Perf při analýze využít i různé typy událostí, mezi nimiž jsou i tracepointy od Ftrace, události software, například změna kontextu CPU. Události dány čítači na CPU, ale i události jako třeba načtení cache pro instrukce nebo naplnění cache TLB se pak označují za události hardware. Dalšími zdroji dat jsou i dynamické trasování přes sondování s kprobe\ref{kprobování}, či uprobe.

Perf dává k dispozici mnoho příkazů, my si představíme jen pár z nich.
\begin{itemize}
    \item \emph{perf list} - příkaz zobrazí podporované události na daném systému. Na většině systémů bude seznam podobný až na události hardware. Ty se mohou lišit dle použitého procesoru a jeho přítomných čítačů výkonu.
    \item \emph{perf stat} - tímto příkazem se spustí počítání událostí v příkazu daném jako poslední argument Perf příkazu. Události se dají specifikovat, dokonce i na události uživatelské a kernelové. Perf pak vypíše statistiky událostí po skončení příkazu v argumentu.
    \item \emph{perf record} - tímto příkazem se Perf připojí k nějakému vláknu procesu a periodicky ukládá své statistiky do nějakého datového souboru. Periodicky zde znamená, že po překročení daného čítače (který čítá vyvolání nějaké předem dané události, výchozí událostí jsou cykly na procesoru) Perf vytvoří statistiky. Tento příkaz dovoluje zaznamenávat i statistiky pro všechna vlákna na montorovaném CPU.
    \item \emph{perf record} - tento příkaz interpretuje data v souboru vytvořeném při \texttt{perf record}.
    \item \emph{perf top} - v reálném čase ukazuje procesy/funkce s nejvyšší spotřebou CPU.
\end{itemize}
Krom příkazů podporuje Perf i spouštění skriptů. Nativně je například podporován skript pro FlameGraphs (viz v druhé kapitole \ref{flamegrafy}), které slouží k analýze zásobníku v čase. Dalším zajímavým skriptem je Gecko od organizace Mozilla, který slouží k analýze webových aplikací.

\subsection{Kprobes}
\label{kprobování}

Dynamičtější přístup k trasovní se objevil u technologie Kprobes. Podobně jako tracepointy, i Kprobes se přidávají do kódu kernelu. Ale narozdíl od statických tracepointů, jež je nutné definovat před kompilací, lze Kprobes přidávat za běhu kernelu. Kprobes se ve skutečností dělí na \texttt{kprobe} a \texttt{kretprobe}. První mohou být přidány skoro všude v kernelu, druhé při návratu z funkcí. Aby šlo technologii využívat, je většinou zkompilována jako kernelový modul a jsou přidány registrační a deregistrační funkce. Registrační funkce pak dostává handler, který se spustí, když program narazí na kprobe.

Kprobe funguje na principu přerušení CPU. Při registraci si uloží sondovanou instrukci. Kprobe pak v originální sondované instrukci změní první bajt či bajty, aby se výpočet přerušil. Kprobe pak zavolá svůj handler, udělá nějakou práci, a nechá CPU běžet dále pomocí kopie sondované instrukce. Důležité je, že v moment práce má kprobe přístup ke všem registrům CPU, tedy i k registru z ukazatelem na vykonávanou instrukci. Proto je nutné při psaní handlerů pro Kprobes být maximálně opatrní, abychom nerozbili kernel zevnitř při použití této technologie.

Kretprobe vytvoří na vstupu funkce, jejímž je členem, kprobe (té uživatel může i nemusí dát vlastní handler). Kprobes si pak při vchodu do funkce a vyvolání vchodové sondy uloží návratovou adresu a originál nahradí adresou do libovolné části kódu, často k nějaké \texttt{nop} instrukci. Tím vytvoří, jak tomu říká dokumentace kernelu, jakousi \uv{trampolínu}, v níž je další kprobe (v této je handler, který uživatel musí pro kretprobe specifikovat). Když se pak sondovaná funkce (ta s vchodovou kprobe) vrátit, skočí namísto toho do trampolíny. Handler trampolíny zavolá uživatelem specifikovaný handler a Kprobes pak obnoví původní návratovou adresu z uložené kopie a výpočet pokračuje dál jako obyčejně. Kprobes má mechanismy i pro zvládání rekurzivních funkcí, které by kretprobe využívaly.

Kprobes očividně nutí CPU často zastavovat, proto lze kernel postavit s možností \texttt{CONFIG\_OPTPROBES=y}, že namísto přerušení se při nalezení kprobe někam prostě skočí. 

Kprobes si udržují černou listinu funkcí, ve kterých Kprobes operovat nesmí. Lze ji rozšířit pomocí makra \texttt{NOKPROBE\_SYMBOL()} ze souboru \texttt{linux/kprobes.h}. Hlavními členy listiny jsou funkce od samotných Kprobes.

Podobnými technologiemi ke Kprobes jsou Uprobes, které se dají použít v uživatelském prostoru, a Fprobes, které fungují podobně jako function-graph tracer, ale lze přes ně trasovat pouze vybrané funkce namísto všech.

\subsection{Histogramy událostí}
\label{histogramy-událostí}

Histogramy událostí jsou speciální spouštěče u událostí, které agregují vyvolání událostí a data události, pokud lze. Formát spouštěče je následující:
\begin{code}
hist:keys=<field1[,field2,...]>[:values=<field1[,field2,...]>]
  [:sort=<field1[,field2,...]>][:size=#entries][:pause][:continue]
  [:clear][:name=histname1][:nohitcount][:<handler>.<action>]
  [if <filter>]
\end{code}
Po spuštění bude v podadresáři události v trasovacím adresáři (tj. v \texttt{[trasovací adresář]/events/[název události]}) nový soubor s názvem \texttt{hist}, tedy na stejném místě jako soubory pro definice filtrů a spouštěčů pro danou událost. Pomocí spouštěčů \texttt{disable/enable\_hist:<system>:<event>[:count]} lze zapínat a vypínat spouštěče histogramů. Tyto spouštěče jsou podobné spouštěčům pro zapínání a vypínání událostí. Lze tak vytvořit další pravidla vedle filtrů, která určují, kdy sbírat data pro histogramy.

\subsubsection*{Vysvětlení formátu spouštěče}
Klíče a hodnoty musí být datová pole z formátu události, hodnoty také musí být číselné, aby bylo možné je sčítat. Pokud nejsou hodnoty specifikovány, implicitně se použije \uv{hitcount} hodnota, které pouze sčítá, kolikrát trasování natrefilo na událost. Pokud zapíšeme jako klíče pole \uv{common\_stacktrace}, čímž jako klíč použijeme zásobník kernelu při této události. Klíče mohou být složené (více polí dohromady, maximálně tři) či jednoduché (jedno pole), přičemž různé permutace prvků ve složeném klíči vytvářejí různé klíče. Pro vytvoření složeného klíče stačí jednotlivé části klíče oddělit čárkou. Složené klíče lze pak setřídit pomocí parametru \texttt{sort} a specifikace až dvou polí. U dvou třídících polí pak budou setříděny nejprve podle prvního klíče a pak podle druhého klíče. Sort lze nicméně použít i na hodnoty a třídit podle nich. Pokud dáme histogramu jméno přes parametr \texttt{name} a toto jméno použijeme i u jiných histogramových spouštěčů, budou vytvořené histogramy tato data sdílet. Sdílení je možné pouze tehdy, pokud jsou spouštěče kompatibilní, tj. mají stejný počet polí, pole jsou stejně nazvaná a pole mají stejný typ. Hodnoty oddělené čárkou pro \texttt{values} se sčítají.

Existují speciální pole, které lze použít pro klíče i hodnoty pro jakékoliv hodnoty, ačkoliv nejsou součástí formátu události. Jsou jimi \texttt{common\_timestamp} typu nezáporného 64-bitového čísla a \texttt{common\_cpu} typu 32-bitového znaménkového celého čísla. První pole je časová značka, kdy byla událost zaznamenána. Druhé pole říká, na kterém CPU se událost stala.

Je možné dodat i další parametry a modifikace do spouštěče. Parametr \texttt{nohitcount} nezobrazí hodnotu hitcount v histogramu. Pokud je toto použito, je nutné dodat nějakou hodnotu, která není \uv{holý hitcount}, nelze tedy zobrazit \texttt{vals=hitcount:nohitcount}, ale lze zobrazit \texttt{vals=common\_pid:nohitcount} nebo \texttt{vals=hitcount.percent:nohitcount}.

Modifikátor \texttt{.percent} je jedním z několika modifikátorů pro hodnoty, které se ve výchozím nastavení zobrazí jako zobrazí číslo jako celá čísla v desítkové soustavě. Dalšími modifikátory jsou třeba \texttt{.hex}, který zobrazí čísla v hexadecimální formě, \texttt{.log2} zobrazí dvojkový logaritmus čísla, \texttt{.execname} zobrazí PID jako jméno procesu (zde musí být hodnota z pole \texttt{common\_pid}), \texttt{.stacktrace} dokáže zobrazit zásobník (zde musí hodnota být typu long[]) a nebo \texttt{.sym}, kdy se číslo interpretuje jako adresa nějakého symbolu.

Kromě části \texttt{if <filter>}, která funguje stejně jako u jiných spouštěčů, stačí vysvětlit parametr \text{:handler.action}. Action je funkce, která se zavolá při přidání či aktualizaci histogramu. Handler rozhoduje, zdali má být action zavolána, nebo ne.Výchozí nastavení tohoto parametru je prostá aktualizace dat v histogramu. Pokud chceme udělat více práce, třeba vyvolání další události, pak můžeme právě tento pár nastavit sami. Na výběr máme z několika předdefinovaných handlerů a action funkcí. Handlery jsou:
\begin{itemize}
    \item onmatch(matching.event) - zavolá action funkci při přidání nebo změně týkající se události \uv{matching.event} (událost lze zapsat jako subsystém.událost, např. sched.sched\_switch).
    \item onmax(var) - zavolá action pokud histogramová proměnná překročí nějakou hodnotu.
    \item onchange(var) - action zavolá při změně histogramové proměnné.
\end{itemize}
Dostupné action funkce jsou:
\begin{itemize}
    \item trace(<název umělé událost>,seznam parametrů) - vygeneruje umělou událost, seznam parametrů pak určuje další datová pole v ní
    \item save(pole,...) - uloží aktuální data ve specifikovaných polích události, která spouštěč vlastní
    \item snapshot() - vytvoří snapshot trasovacího bufferu, který bude uložen do souboru \texttt{snapshot} v trasovacím adresáři
\end{itemize}
Ačkoliv teorie nikterak nebrání všem kombinacím handlerů a action funkcí, ne všechny jsou podporované. Pokud jsou použity, spouštěč se nespustí a vrátí chybový kód \texttt{-EINVAL}.

\subsubsection*{Histogramové proměnné}

Histogramy dokážou pracovat s proměnnými, místy k ukládání dat z různých procesů a spouštěčů. Vytvářejí se přes syntax \texttt{název\_proměnné=\$datové\_pole} a jsou přístupné globálně nebo lokálně pro nějaký klíč. K získání hodnoty v proměnné stačí napsat \texttt{\$název\_proměnné}. Do proměnných lze ukládat i trasovaný zásobník, nebo číselné literály. Hodnoty se samy od sebe nemění, kromě situace, kdy je proměnná použita v nějakém aritmetickém výrazu, poté svou hodnotu zahodí, dokud není znovu nastavena. Lze vytvořit i několik proměnných, stačí je oddělit dvojtečkami v definici spouštěče. Na pozici vytvoření proměnné ve spouštěči nezáleží, tj. lze použít proměnnou a definovat ji později. Příklad chování:
\begin{code}
echo 'hist:keys=pid:ts=\$timestamp' > \
/sys/kernel/tracing/events/sched/sched\_waking/trigger

echo 'hist:keys=next_pid:wake_switch_lat=\$timestamp-\$ts' > \
/sys/kernel/tracing/events/sched/sched\_switch/trigger
\end{code}
První příklad uloží časovou značku při události sched\_waking do proměnné \emph{ts}. Proměnná je viditelná všem událostem se stejným PID jako v next\_pid. Druhý příkaz vypočítá čas mezi sched\_waking a sched\_switch pro daný PID, určený polem next\_pid. Po spočítání výrazu bude proměnná \texttt{\$ts} prázdná a nelze ji použít, dokud není nastavená. Tento mechanismus zajistí, že hodnota v proměnné nebude použita se staršími daty v dalších sched\_switch událostech.

\subsubsection*{Inter-event histogramy}

Takto se označují histogramy, které kombinují data z několika různých událostí. Často jsou takovými histogramy zkoumány latence, například mezi probuzením procesu a přepnutím kontextu, nicméně systém pro podporu takových histogramů je obecnější a lze kombinovat více druhů dat. Tyto histogramy pak logicky nepatří žádné z událostí, patří všem naráz. Kvůli inter-event histogramům byly vytvořeny action funkce, podpora pro vytváření umělých událostí (ty pak sdružují data z několika událostí), histogramové proměnné, pole common\_timestamp a podpora jednoduchých aritmetických operací.

\subsection{Další trasovací technologie}

Jak kapitola ukázala výše, Linux podporuje trasování různě a široce. Existuje mnoho technologií, některé jsme rozebrali výše. Technologie níže byly označeny za zajímavé, ale ne příliš relevantní ke zbytku práce. Jejich popis tedy bude krátký, vyznačující jejich záměry, některé charakteristiky a schopnosti. Pro detaily a další nástroje autor vřele doporučuje přečíst si oficiální dokumentaci kernelu.

\subsubsection*{Boot-time trasování}

Trasování při bootování dovoluje uživateli trasovat procesy, které se dějí například při inicializaci zařízení. Navíc je plně podporován Ftrace a jeho funkcionality. K zapnutí je nutné modifikovat nastavení bootování. Ftrace je pak také konfigurován v souboru pro boot. Při tomto trasování lze mít i více instancí Ftrace běžících naráz, tedy i víc tracerů, čímž lze získat více dat o spouštění systému, než pouze z jednoho traceru.

\subsubsection*{Uživatelské události}

Tato technologie dovoluje uživatelům bez privilegovaného módu vytvářet vlastní trasovací události, které jsou zpracovatelné nástroji Ftrace i Perf. Aby k této možnosti byl přístup, musí být použita možnost \texttt{CONFIG\_USER\_EVENTS=y} při sestavování kernelu. Tracefs pak bude obsahovat další soubory pro tyto uživatelské události.

\subsubsection*{OSNOISE Tracer}

OSNOISE je využíván v HPC (High Performance Computing) prostředí k měření interference, kterou pociťují aplikace kvůli aktivitám uvnitř operačního systému, tedy prodlevy způsobené chováním operačního systému či chováním hardwaru. Nejpřímějším příkladem v Linuxu jsou obyčejné žádosti o přerušení (IRQ), SoftIRQ, ale zdroji mohou být i přerušení vzniklá chybou hardware (NMI/Non-maskable interrupt) či jiné práce systémových vláken. OSNOISE pak aktivity, které zdržují, označuje za šum. Z tohoto označení vychází název traceru, OS (operační systém) + NOISE (šum), tj. tracer \uv{šumu operačního systému}.

OSNOISE pracuje podobně jako hwlat\_detector (Hardware Latency Detector) tracer. Periodicky spustí smyčku ve vlastním vlákně a v ní sbírá data o šumu. Narozdíl od hwlat\_detector traceru nevypíná přerušení (tj. IRQ a SoftIRQ) a nechá vše běžet v preemptivním režimu - tím si zajišťuje detekci všech druhů interference. Při každém průchodu smyčkou detekuje vstupní události NMI, IRQ, SoftIRQ či plánování vláken a zvyšuje odpovídající čítače. Pokud prodleva nevznikne žádným z těchto zdrojů, zvýší se čítač hardwarového šumu. OSNOISE po ukončení smyčky zobrazí statistiky z trasování, např. nejvýraznější ze šumů nebo procentuální dostupnost CPU pro nějaké vlákno.

\subsubsection*{RV - Runtime Verification}

RV je mechanismus založený na trasování, který slouží k monitorování běhu systému podle předem definovaných vlastností či pravidel. Ty jsou typicky zapsány ve formě automatů. Na rozdíl od klasického trasování, kde se zaznamenávají všechny události, RV kontroluje, zda sledovaný běh odpovídá očekávanému chování. Při porušení očekávání může vyvolat událost. Používá se například pro bezpečnostní monitoring, nebo formální ověření určitých vlastností v jádře. Tato metoda je rigorózní a zároveň nenáročná pro systém.

\section{LTTng - Linux Trace Toolkit: next generation}

[TODO: https://lttng.org]

Projekt oddělený od Linuxového jádra, ale také zaměřený na trasování, \emph{LTTng} je kolekcí kernelových modulů, s nimiž lze trasovat kernel, a dynamických knihoven, které slouží k trasování uživatelských programů a knihoven. LTTng se snaží být alternativou k existujícím trasovacím nástrojům a jejich ekosystému. Software je ve vývoji již od roku 2005 a byl navržen pro minimální dopad na výkon ostatních procesů při svém běhu. Projekt je open-source a dodnes velmi aktivní. Podporován je několika známými distribucemi, například ArchLinux, Ubuntu či Debian.

LTTng pak pracuje jako démon a uživatel s ním komunikuje přes jediný program s rozhraním pro terminál. LTTng dokáže trasovací data vytvářet, přičemž lze filtrovat události, které chceme zaznamenat, program dokáže i vytvářet spouštěče, a nebo dodává vlastní definice pro vytváření tracepointů. Trasovat lze přes síť, lokálně, paralelně (tj. lze zaznamenávat více různě nakonfigurovaných trasovacích dat naráz) a i v reálném čase. Zaznamenaná data poté přestavují unifikovaný log událostí, kde se mohou i míchat události z uživatelského prostoru s událostmi kernelu.

Data od LTTng pak může číst sada nástrojů \emph{Babeltrace} nebo GUI program \emph{TraceCompass}.